"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.js":
/*!********************!*\
  !*** ./lib/api.js ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getRecommendations: () => (/* binding */ getRecommendations)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    timeout: 5000 // 5 second timeout\n});\n// Detect if we're in development mode or if development mode is forced\nconst isDevelopmentMode = ()=>{\n    return  true || 0;\n};\n// Add a request interceptor to include the auth token in requests\napi.interceptors.request.use((config)=>{\n    if (true) {\n        const token = localStorage.getItem('auth_token');\n        if (token) {\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    return config;\n}, (error)=>Promise.reject(error));\n// Add a response interceptor to handle errors\napi.interceptors.response.use((response)=>response, (error)=>{\n    console.log('API error intercepted:', error.message);\n    // If we get authorization errors, we might want to switch to dev mode\n    if (error.response && error.response.status === 401) {\n        console.warn('Authentication failed (401) - Consider enabling development mode');\n    }\n    // For timeouts and network errors, auto-enable dev mode\n    if (error.code === 'ECONNABORTED' || error.message.includes('Network Error')) {\n        console.warn('Network error or timeout - switching to development mode');\n        if (true) {\n            localStorage.setItem('dev_mode_forced', 'true');\n        }\n    }\n    return Promise.reject(error);\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (api);\nconst getRecommendations = async (tripData)=>{\n    try {\n        // Check if we should use mock data based on development mode\n        if (isDevelopmentMode()) {\n            console.log('Using development mode for recommendations');\n            return await getMockRecommendations(tripData);\n        }\n        // Try the real API call with the public endpoint that doesn't require auth\n        const res = await api.post('/public/getRecommendations', tripData, {\n            timeout: 3000\n        });\n        console.log('API recommendation response received:', res.data);\n        return res.data;\n    } catch (error) {\n        console.error('Error fetching recommendations:', error);\n        console.log('Falling back to mock recommendations...');\n        // If the API call fails, use the mock data\n        return await getMockRecommendations(tripData);\n    }\n};\n// Function to generate mock recommendations with geocoding\nconst getMockRecommendations = async (tripData)=>{\n    console.log('Generating mock recommendations for:', tripData);\n    try {\n        // Default coordinates in case geocoding fails\n        let startCoords = {\n            lat: 37.7749,\n            lng: -122.4194\n        }; // San Francisco\n        let destCoords = {\n            lat: 34.0522,\n            lng: -118.2437\n        }; // Los Angeles\n        // Try to geocode if Google Maps is available\n        if (window.google && window.google.maps && window.google.maps.Geocoder) {\n            try {\n                console.log('Geocoding locations...');\n                const geocoder = new window.google.maps.Geocoder();\n                // Geocode start location\n                const startResult = await new Promise((resolve, reject)=>{\n                    geocoder.geocode({\n                        address: tripData.start\n                    }, (results, status)=>{\n                        if (status === 'OK' && results[0]) {\n                            resolve(results[0]);\n                        } else {\n                            reject(\"Start location geocoding failed: \".concat(status));\n                        }\n                    });\n                });\n                // Geocode destination\n                const destResult = await new Promise((resolve, reject)=>{\n                    geocoder.geocode({\n                        address: tripData.destination\n                    }, (results, status)=>{\n                        if (status === 'OK' && results[0]) {\n                            resolve(results[0]);\n                        } else {\n                            reject(\"Destination geocoding failed: \".concat(status));\n                        }\n                    });\n                });\n                // Update coordinates with geocoded results\n                startCoords = {\n                    lat: startResult.geometry.location.lat(),\n                    lng: startResult.geometry.location.lng()\n                };\n                destCoords = {\n                    lat: destResult.geometry.location.lat(),\n                    lng: destResult.geometry.location.lng()\n                };\n                console.log('Successfully geocoded locations:', {\n                    start: startCoords,\n                    destination: destCoords\n                });\n            } catch (geocodeError) {\n                console.error('Geocoding failed:', geocodeError);\n                console.log('Using default coordinates');\n            }\n        } else {\n            console.log('Google Maps Geocoder not available, using default coordinates');\n        }\n        // Calculate midpoint for stops\n        const midLat = (startCoords.lat + destCoords.lat) / 2;\n        const midLng = (startCoords.lng + destCoords.lng) / 2;\n        // Create mock response\n        return {\n            route: {\n                stops: [\n                    {\n                        location: startCoords,\n                        type: 'start',\n                        name: tripData.start\n                    },\n                    {\n                        location: {\n                            lat: midLat + (Math.random() * 0.05 - 0.025),\n                            lng: midLng + (Math.random() * 0.05 - 0.025)\n                        },\n                        type: 'restaurant',\n                        name: 'Recommended Restaurant'\n                    },\n                    {\n                        location: {\n                            lat: midLat + (Math.random() * 0.05 - 0.025),\n                            lng: midLng + (Math.random() * 0.05 - 0.025)\n                        },\n                        type: 'gas',\n                        name: 'Recommended Gas Station'\n                    },\n                    {\n                        location: destCoords,\n                        type: 'destination',\n                        name: tripData.destination\n                    }\n                ],\n                googleMapsLink: \"https://www.google.com/maps/dir/\".concat(encodeURIComponent(tripData.start), \"/\").concat(encodeURIComponent(tripData.destination), \"/\")\n            }\n        };\n    } catch (error) {\n        console.error('Error creating mock recommendations:', error);\n        throw new Error('Failed to generate recommendations');\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dXJjZXMiOlsiRDpcXFN0dWRpZXNcXENvZGluZ1xcT25Sb3V0ZVxcYWktcm9hZHRyaXAtZnJvbnRlbmRcXGxpYlxcYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcblxyXG5jb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xyXG4gIGJhc2VVUkw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGknLFxyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfSxcclxuICB0aW1lb3V0OiA1MDAwIC8vIDUgc2Vjb25kIHRpbWVvdXRcclxufSk7XHJcblxyXG4vLyBEZXRlY3QgaWYgd2UncmUgaW4gZGV2ZWxvcG1lbnQgbW9kZSBvciBpZiBkZXZlbG9wbWVudCBtb2RlIGlzIGZvcmNlZFxyXG5jb25zdCBpc0RldmVsb3BtZW50TW9kZSA9ICgpID0+IHtcclxuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgfHwgXHJcbiAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGV2X21vZGVfZm9yY2VkJykgPT09ICd0cnVlJyk7XHJcbn07XHJcblxyXG4vLyBBZGQgYSByZXF1ZXN0IGludGVyY2VwdG9yIHRvIGluY2x1ZGUgdGhlIGF1dGggdG9rZW4gaW4gcmVxdWVzdHNcclxuYXBpLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcclxuICAoY29uZmlnKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aF90b2tlbicpO1xyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb25maWc7XHJcbiAgfSxcclxuICAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKVxyXG4pO1xyXG5cclxuLy8gQWRkIGEgcmVzcG9uc2UgaW50ZXJjZXB0b3IgdG8gaGFuZGxlIGVycm9yc1xyXG5hcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcclxuICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLFxyXG4gIChlcnJvcikgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ0FQSSBlcnJvciBpbnRlcmNlcHRlZDonLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIFxyXG4gICAgLy8gSWYgd2UgZ2V0IGF1dGhvcml6YXRpb24gZXJyb3JzLCB3ZSBtaWdodCB3YW50IHRvIHN3aXRjaCB0byBkZXYgbW9kZVxyXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignQXV0aGVudGljYXRpb24gZmFpbGVkICg0MDEpIC0gQ29uc2lkZXIgZW5hYmxpbmcgZGV2ZWxvcG1lbnQgbW9kZScpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBGb3IgdGltZW91dHMgYW5kIG5ldHdvcmsgZXJyb3JzLCBhdXRvLWVuYWJsZSBkZXYgbW9kZVxyXG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ05ldHdvcmsgRXJyb3InKSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ05ldHdvcmsgZXJyb3Igb3IgdGltZW91dCAtIHN3aXRjaGluZyB0byBkZXZlbG9wbWVudCBtb2RlJyk7XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdkZXZfbW9kZV9mb3JjZWQnLCAndHJ1ZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgfVxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXBpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFJlY29tbWVuZGF0aW9ucyA9IGFzeW5jICh0cmlwRGF0YSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgdXNlIG1vY2sgZGF0YSBiYXNlZCBvbiBkZXZlbG9wbWVudCBtb2RlXHJcbiAgICBpZiAoaXNEZXZlbG9wbWVudE1vZGUoKSkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVXNpbmcgZGV2ZWxvcG1lbnQgbW9kZSBmb3IgcmVjb21tZW5kYXRpb25zJyk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gYXdhaXQgZ2V0TW9ja1JlY29tbWVuZGF0aW9ucyh0cmlwRGF0YSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFRyeSB0aGUgcmVhbCBBUEkgY2FsbCB3aXRoIHRoZSBwdWJsaWMgZW5kcG9pbnQgdGhhdCBkb2Vzbid0IHJlcXVpcmUgYXV0aFxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJy9wdWJsaWMvZ2V0UmVjb21tZW5kYXRpb25zJywgdHJpcERhdGEsIHtcclxuICAgICAgdGltZW91dDogMzAwMCxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQVBJIHJlY29tbWVuZGF0aW9uIHJlc3BvbnNlIHJlY2VpdmVkOicsIHJlcy5kYXRhKTtcclxuICAgIHJldHVybiByZXMuZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjb21tZW5kYXRpb25zOicsIGVycm9yKTtcclxuICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gbW9jayByZWNvbW1lbmRhdGlvbnMuLi4nKTtcclxuICAgIFxyXG4gICAgLy8gSWYgdGhlIEFQSSBjYWxsIGZhaWxzLCB1c2UgdGhlIG1vY2sgZGF0YVxyXG4gICAgcmV0dXJuIGF3YWl0IGdldE1vY2tSZWNvbW1lbmRhdGlvbnModHJpcERhdGEpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIG1vY2sgcmVjb21tZW5kYXRpb25zIHdpdGggZ2VvY29kaW5nXHJcbmNvbnN0IGdldE1vY2tSZWNvbW1lbmRhdGlvbnMgPSBhc3luYyAodHJpcERhdGEpID0+IHtcclxuICBjb25zb2xlLmxvZygnR2VuZXJhdGluZyBtb2NrIHJlY29tbWVuZGF0aW9ucyBmb3I6JywgdHJpcERhdGEpO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICAvLyBEZWZhdWx0IGNvb3JkaW5hdGVzIGluIGNhc2UgZ2VvY29kaW5nIGZhaWxzXHJcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB7IGxhdDogMzcuNzc0OSwgbG5nOiAtMTIyLjQxOTQgfTsgLy8gU2FuIEZyYW5jaXNjb1xyXG4gICAgbGV0IGRlc3RDb29yZHMgPSB7IGxhdDogMzQuMDUyMiwgbG5nOiAtMTE4LjI0MzcgfTsgIC8vIExvcyBBbmdlbGVzXHJcbiAgICBcclxuICAgIC8vIFRyeSB0byBnZW9jb2RlIGlmIEdvb2dsZSBNYXBzIGlzIGF2YWlsYWJsZVxyXG4gICAgaWYgKHdpbmRvdy5nb29nbGUgJiYgd2luZG93Lmdvb2dsZS5tYXBzICYmIHdpbmRvdy5nb29nbGUubWFwcy5HZW9jb2Rlcikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdHZW9jb2RpbmcgbG9jYXRpb25zLi4uJyk7XHJcbiAgICAgICAgY29uc3QgZ2VvY29kZXIgPSBuZXcgd2luZG93Lmdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2VvY29kZSBzdGFydCBsb2NhdGlvblxyXG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgZ2VvY29kZXIuZ2VvY29kZSh7IGFkZHJlc3M6IHRyaXBEYXRhLnN0YXJ0IH0sIChyZXN1bHRzLCBzdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ09LJyAmJiByZXN1bHRzWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzWzBdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZWplY3QoYFN0YXJ0IGxvY2F0aW9uIGdlb2NvZGluZyBmYWlsZWQ6ICR7c3RhdHVzfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZW9jb2RlIGRlc3RpbmF0aW9uXHJcbiAgICAgICAgY29uc3QgZGVzdFJlc3VsdCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgIGdlb2NvZGVyLmdlb2NvZGUoeyBhZGRyZXNzOiB0cmlwRGF0YS5kZXN0aW5hdGlvbiB9LCAocmVzdWx0cywgc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdPSycgJiYgcmVzdWx0c1swXSkge1xyXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0c1swXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZXN0aW5hdGlvbiBnZW9jb2RpbmcgZmFpbGVkOiAke3N0YXR1c31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXBkYXRlIGNvb3JkaW5hdGVzIHdpdGggZ2VvY29kZWQgcmVzdWx0c1xyXG4gICAgICAgIHN0YXJ0Q29vcmRzID0ge1xyXG4gICAgICAgICAgbGF0OiBzdGFydFJlc3VsdC5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKSxcclxuICAgICAgICAgIGxuZzogc3RhcnRSZXN1bHQuZ2VvbWV0cnkubG9jYXRpb24ubG5nKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBkZXN0Q29vcmRzID0ge1xyXG4gICAgICAgICAgbGF0OiBkZXN0UmVzdWx0Lmdlb21ldHJ5LmxvY2F0aW9uLmxhdCgpLFxyXG4gICAgICAgICAgbG5nOiBkZXN0UmVzdWx0Lmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBnZW9jb2RlZCBsb2NhdGlvbnM6Jywge1xyXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0Q29vcmRzLFxyXG4gICAgICAgICAgZGVzdGluYXRpb246IGRlc3RDb29yZHNcclxuICAgICAgICB9KTtcclxuICAgICAgfSBjYXRjaCAoZ2VvY29kZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignR2VvY29kaW5nIGZhaWxlZDonLCBnZW9jb2RlRXJyb3IpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBkZWZhdWx0IGNvb3JkaW5hdGVzJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdHb29nbGUgTWFwcyBHZW9jb2RlciBub3QgYXZhaWxhYmxlLCB1c2luZyBkZWZhdWx0IGNvb3JkaW5hdGVzJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBtaWRwb2ludCBmb3Igc3RvcHNcclxuICAgIGNvbnN0IG1pZExhdCA9IChzdGFydENvb3Jkcy5sYXQgKyBkZXN0Q29vcmRzLmxhdCkgLyAyO1xyXG4gICAgY29uc3QgbWlkTG5nID0gKHN0YXJ0Q29vcmRzLmxuZyArIGRlc3RDb29yZHMubG5nKSAvIDI7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBtb2NrIHJlc3BvbnNlXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3V0ZToge1xyXG4gICAgICAgIHN0b3BzOiBbXHJcbiAgICAgICAgICB7IFxyXG4gICAgICAgICAgICBsb2NhdGlvbjogc3RhcnRDb29yZHMsIFxyXG4gICAgICAgICAgICB0eXBlOiAnc3RhcnQnLCBcclxuICAgICAgICAgICAgbmFtZTogdHJpcERhdGEuc3RhcnQgXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBsb2NhdGlvbjoge1xyXG4gICAgICAgICAgICAgIGxhdDogbWlkTGF0ICsgKE1hdGgucmFuZG9tKCkgKiAwLjA1IC0gMC4wMjUpLFxyXG4gICAgICAgICAgICAgIGxuZzogbWlkTG5nICsgKE1hdGgucmFuZG9tKCkgKiAwLjA1IC0gMC4wMjUpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0eXBlOiAncmVzdGF1cmFudCcsXHJcbiAgICAgICAgICAgIG5hbWU6ICdSZWNvbW1lbmRlZCBSZXN0YXVyYW50JyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7XHJcbiAgICAgICAgICAgICAgbGF0OiBtaWRMYXQgKyAoTWF0aC5yYW5kb20oKSAqIDAuMDUgLSAwLjAyNSksXHJcbiAgICAgICAgICAgICAgbG5nOiBtaWRMbmcgKyAoTWF0aC5yYW5kb20oKSAqIDAuMDUgLSAwLjAyNSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHR5cGU6ICdnYXMnLFxyXG4gICAgICAgICAgICBuYW1lOiAnUmVjb21tZW5kZWQgR2FzIFN0YXRpb24nLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHsgXHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiBkZXN0Q29vcmRzLCBcclxuICAgICAgICAgICAgdHlwZTogJ2Rlc3RpbmF0aW9uJywgXHJcbiAgICAgICAgICAgIG5hbWU6IHRyaXBEYXRhLmRlc3RpbmF0aW9uIFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGdvb2dsZU1hcHNMaW5rOiBgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL2Rpci8ke2VuY29kZVVSSUNvbXBvbmVudChcclxuICAgICAgICAgIHRyaXBEYXRhLnN0YXJ0XHJcbiAgICAgICAgKX0vJHtlbmNvZGVVUklDb21wb25lbnQodHJpcERhdGEuZGVzdGluYXRpb24pfS9gLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgbW9jayByZWNvbW1lbmRhdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgcmVjb21tZW5kYXRpb25zJyk7XHJcbiAgfVxyXG59O1xyXG4iXSwibmFtZXMiOlsiYXhpb3MiLCJhcGkiLCJjcmVhdGUiLCJiYXNlVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJoZWFkZXJzIiwidGltZW91dCIsImlzRGV2ZWxvcG1lbnRNb2RlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ0b2tlbiIsIkF1dGhvcml6YXRpb24iLCJlcnJvciIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNwb25zZSIsImNvbnNvbGUiLCJsb2ciLCJtZXNzYWdlIiwic3RhdHVzIiwid2FybiIsImNvZGUiLCJpbmNsdWRlcyIsInNldEl0ZW0iLCJnZXRSZWNvbW1lbmRhdGlvbnMiLCJ0cmlwRGF0YSIsImdldE1vY2tSZWNvbW1lbmRhdGlvbnMiLCJyZXMiLCJwb3N0IiwiZGF0YSIsInN0YXJ0Q29vcmRzIiwibGF0IiwibG5nIiwiZGVzdENvb3JkcyIsIndpbmRvdyIsImdvb2dsZSIsIm1hcHMiLCJHZW9jb2RlciIsImdlb2NvZGVyIiwic3RhcnRSZXN1bHQiLCJyZXNvbHZlIiwiZ2VvY29kZSIsImFkZHJlc3MiLCJzdGFydCIsInJlc3VsdHMiLCJkZXN0UmVzdWx0IiwiZGVzdGluYXRpb24iLCJnZW9tZXRyeSIsImxvY2F0aW9uIiwiZ2VvY29kZUVycm9yIiwibWlkTGF0IiwibWlkTG5nIiwicm91dGUiLCJzdG9wcyIsInR5cGUiLCJuYW1lIiwiTWF0aCIsInJhbmRvbSIsImdvb2dsZU1hcHNMaW5rIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.js\n"));

/***/ })

});