"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/auth.js":
/*!*********************!*\
  !*** ./lib/auth.js ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   isAuthenticated: () => (/* binding */ isAuthenticated),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   logout: () => (/* binding */ logout),\n/* harmony export */   signup: () => (/* binding */ signup)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Create API client with proper error handling\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    timeout: 5000\n});\n// Detect if we're in development mode and there's no backend\nconst isDevelopmentWithoutBackend = ()=>{\n    return  true && !process.env.NEXT_PUBLIC_API_URL;\n};\n// Add a request interceptor to include the auth token in requests\napi.interceptors.request.use((config)=>{\n    if (true) {\n        const token = localStorage.getItem('auth_token');\n        if (token) {\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    return config;\n}, (error)=>Promise.reject(error));\n// Handle authentication errors consistently\napi.interceptors.response.use((response)=>response, (error)=>{\n    console.log('API error intercepted:', error.message);\n    // Add more detailed error information for auth errors\n    if (error.response) {\n        var _error_response_data;\n        if (error.response.status === 401) {\n            // Clear tokens on auth failure\n            if (true) {\n                localStorage.removeItem('auth_token');\n            }\n            // Add a user-friendly message\n            error.userMessage = 'Your session has expired. Please login again.';\n        }\n        if (error.response.status === 400 && ((_error_response_data = error.response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message)) {\n            // Pass along the server message\n            error.userMessage = error.response.data.message;\n        }\n    } else if (error.code === 'ECONNABORTED') {\n        // Special handling for timeouts\n        error.userMessage = 'Request timed out. Please check your connection and try again.';\n        console.warn('API request timed out - switching to development mode');\n        // Force development mode on timeout\n        localStorage.setItem('dev_mode_forced', 'true');\n    }\n    return Promise.reject(error);\n});\nconst login = async (email, password)=>{\n    try {\n        // Check if we should use mock data\n        const useMockData = isDevelopmentWithoutBackend() || localStorage.getItem('dev_mode_forced') === 'true';\n        if (useMockData) {\n            console.log('Using mock login in development mode');\n            // Simulate network delay\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            // Store the mock token\n            localStorage.setItem('auth_token', 'mock-jwt-token');\n            // Store basic user data\n            localStorage.setItem('user_preferences', JSON.stringify({\n                name: email.split('@')[0],\n                email: email,\n                foodPreferences: {\n                    foodTypes: [\n                        'Fast Food',\n                        'Mexican'\n                    ],\n                    favoriteChains: [\n                        'Taco Bell',\n                        'McDonald\\'s'\n                    ],\n                    dietaryRestrictions: []\n                }\n            }));\n            return {\n                token: 'mock-jwt-token',\n                user: {\n                    id: '123',\n                    name: email.split('@')[0],\n                    email: email\n                }\n            };\n        }\n        // Real API call\n        const response = await api.post('/auth/login', {\n            email,\n            password\n        });\n        // Store the token\n        if (response.data && response.data.token) {\n            localStorage.setItem('auth_token', response.data.token);\n        }\n        return response.data;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        // Log for debugging\n        console.error('Login error details:', error);\n        // Throw a more detailed error\n        const errorMessage = error.userMessage || ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message || 'Login failed';\n        const errorObj = new Error(errorMessage);\n        errorObj.response = error.response;\n        errorObj.request = error.request;\n        throw errorObj;\n    }\n};\nconst signup = async (name, email, password)=>{\n    try {\n        // Check if we should use mock data\n        const useMockData = isDevelopmentWithoutBackend() || localStorage.getItem('dev_mode_forced') === 'true';\n        if (useMockData) {\n            console.log('Using mock signup in development mode');\n            // Simulate network delay\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            // Store the mock token\n            localStorage.setItem('auth_token', 'mock-jwt-token');\n            // Store basic user data\n            localStorage.setItem('user_preferences', JSON.stringify({\n                name: name,\n                email: email,\n                foodPreferences: {\n                    foodTypes: [],\n                    favoriteChains: [],\n                    dietaryRestrictions: []\n                }\n            }));\n            return {\n                token: 'mock-jwt-token',\n                user: {\n                    id: '123',\n                    name: name,\n                    email: email\n                }\n            };\n        }\n        // Real API call\n        const response = await api.post('/auth/signup', {\n            name,\n            email,\n            password\n        });\n        // Store the token\n        if (response.data && response.data.token) {\n            localStorage.setItem('auth_token', response.data.token);\n        }\n        return response.data;\n    } catch (error) {\n        var _error_response, _error_response_data, _error_response1;\n        // Log for debugging\n        console.error('Signup error details:', error);\n        // Check for email already exists error\n        if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 400 && error.response.data.message.includes('already exists')) {\n            const errorObj = new Error('This email is already registered');\n            errorObj.response = error.response;\n            errorObj.request = error.request;\n            throw errorObj;\n        }\n        // Throw a more detailed error\n        const errorMessage = error.userMessage || ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message || 'Signup failed';\n        const errorObj = new Error(errorMessage);\n        errorObj.response = error.response;\n        errorObj.request = error.request;\n        throw errorObj;\n    }\n};\nconst logout = ()=>{\n    if (true) {\n        localStorage.removeItem('auth_token');\n        localStorage.removeItem('dev_mode_forced');\n    }\n};\nconst getCurrentUser = async ()=>{\n    try {\n        // Check if we should use mock data\n        const useMockData = isDevelopmentWithoutBackend() || localStorage.getItem('dev_mode_forced') === 'true';\n        if (useMockData) {\n            console.log('Using mock user data in development mode');\n            // Get stored user preferences or create default\n            const userData =  true ? JSON.parse(localStorage.getItem('user_preferences') || '{}') : 0;\n            return {\n                id: '123',\n                name: userData.name || 'Test User',\n                email: userData.email || 'test@example.com',\n                preferences: userData.foodPreferences || {\n                    foodTypes: [],\n                    favoriteChains: [],\n                    dietaryRestrictions: []\n                }\n            };\n        }\n        const response = await api.get('/auth/me');\n        return response.data;\n    } catch (error) {\n        console.error('Get current user error:', error);\n        return null;\n    }\n};\n// Check if the user is authenticated\nconst isAuthenticated = ()=>{\n    if (false) {}\n    return !!localStorage.getItem('auth_token');\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hdXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEI7QUFFMUIsK0NBQStDO0FBQy9DLE1BQU1DLE1BQU1ELDZDQUFLQSxDQUFDRSxNQUFNLENBQUM7SUFDdkJDLFNBQVNDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7SUFDNUNDLFNBQVM7UUFDUCxnQkFBZ0I7SUFDbEI7SUFDQUMsU0FBUztBQUNYO0FBRUEsNkRBQTZEO0FBQzdELE1BQU1DLDhCQUE4QjtJQUNsQyxPQUFPTCxLQUFzQyxJQUFJLENBQUNBLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CO0FBQ25GO0FBRUEsa0VBQWtFO0FBQ2xFTCxJQUFJUyxZQUFZLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUMxQixDQUFDQztJQUNDLElBQUksSUFBNkIsRUFBRTtRQUNqQyxNQUFNQyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7UUFDbkMsSUFBSUYsT0FBTztZQUNURCxPQUFPTixPQUFPLENBQUNVLGFBQWEsR0FBRyxVQUFnQixPQUFOSDtRQUMzQztJQUNGO0lBQ0EsT0FBT0Q7QUFDVCxHQUNBLENBQUNLLFFBQVVDLFFBQVFDLE1BQU0sQ0FBQ0Y7QUFHNUIsNENBQTRDO0FBQzVDakIsSUFBSVMsWUFBWSxDQUFDVyxRQUFRLENBQUNULEdBQUcsQ0FDM0IsQ0FBQ1MsV0FBYUEsVUFDZCxDQUFDSDtJQUNDSSxRQUFRQyxHQUFHLENBQUMsMEJBQTBCTCxNQUFNTSxPQUFPO0lBRW5ELHNEQUFzRDtJQUN0RCxJQUFJTixNQUFNRyxRQUFRLEVBQUU7WUFXbUJIO1FBVnJDLElBQUlBLE1BQU1HLFFBQVEsQ0FBQ0ksTUFBTSxLQUFLLEtBQUs7WUFDakMsK0JBQStCO1lBQy9CLElBQUksSUFBNkIsRUFBRTtnQkFDakNWLGFBQWFXLFVBQVUsQ0FBQztZQUMxQjtZQUVBLDhCQUE4QjtZQUM5QlIsTUFBTVMsV0FBVyxHQUFHO1FBQ3RCO1FBRUEsSUFBSVQsTUFBTUcsUUFBUSxDQUFDSSxNQUFNLEtBQUssU0FBT1AsdUJBQUFBLE1BQU1HLFFBQVEsQ0FBQ08sSUFBSSxjQUFuQlYsMkNBQUFBLHFCQUFxQk0sT0FBTyxHQUFFO1lBQ2pFLGdDQUFnQztZQUNoQ04sTUFBTVMsV0FBVyxHQUFHVCxNQUFNRyxRQUFRLENBQUNPLElBQUksQ0FBQ0osT0FBTztRQUNqRDtJQUNGLE9BQU8sSUFBSU4sTUFBTVcsSUFBSSxLQUFLLGdCQUFnQjtRQUN4QyxnQ0FBZ0M7UUFDaENYLE1BQU1TLFdBQVcsR0FBRztRQUNwQkwsUUFBUVEsSUFBSSxDQUFDO1FBRWIsb0NBQW9DO1FBQ3BDZixhQUFhZ0IsT0FBTyxDQUFDLG1CQUFtQjtJQUMxQztJQUVBLE9BQU9aLFFBQVFDLE1BQU0sQ0FBQ0Y7QUFDeEI7QUFHSyxNQUFNYyxRQUFRLE9BQU9DLE9BQU9DO0lBQ2pDLElBQUk7UUFDRixtQ0FBbUM7UUFDbkMsTUFBTUMsY0FBYzFCLGlDQUNETSxhQUFhQyxPQUFPLENBQUMsdUJBQXVCO1FBRS9ELElBQUltQixhQUFhO1lBQ2ZiLFFBQVFDLEdBQUcsQ0FBQztZQUVaLHlCQUF5QjtZQUN6QixNQUFNLElBQUlKLFFBQVFpQixDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1lBRWpELHVCQUF1QjtZQUN2QnJCLGFBQWFnQixPQUFPLENBQUMsY0FBYztZQUVuQyx3QkFBd0I7WUFDeEJoQixhQUFhZ0IsT0FBTyxDQUFDLG9CQUFvQk8sS0FBS0MsU0FBUyxDQUFDO2dCQUN0REMsTUFBTVAsTUFBTVEsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN6QlIsT0FBT0E7Z0JBQ1BTLGlCQUFpQjtvQkFDZkMsV0FBVzt3QkFBQzt3QkFBYTtxQkFBVTtvQkFDbkNDLGdCQUFnQjt3QkFBQzt3QkFBYTtxQkFBYztvQkFDNUNDLHFCQUFxQixFQUFFO2dCQUN6QjtZQUNGO1lBRUEsT0FBTztnQkFDTC9CLE9BQU87Z0JBQ1BnQyxNQUFNO29CQUNKQyxJQUFJO29CQUNKUCxNQUFNUCxNQUFNUSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3pCUixPQUFPQTtnQkFDVDtZQUNGO1FBQ0Y7UUFFQSxnQkFBZ0I7UUFDaEIsTUFBTVosV0FBVyxNQUFNcEIsSUFBSStDLElBQUksQ0FBQyxlQUFlO1lBQUVmO1lBQU9DO1FBQVM7UUFFakUsa0JBQWtCO1FBQ2xCLElBQUliLFNBQVNPLElBQUksSUFBSVAsU0FBU08sSUFBSSxDQUFDZCxLQUFLLEVBQUU7WUFDeENDLGFBQWFnQixPQUFPLENBQUMsY0FBY1YsU0FBU08sSUFBSSxDQUFDZCxLQUFLO1FBQ3hEO1FBRUEsT0FBT08sU0FBU08sSUFBSTtJQUN0QixFQUFFLE9BQU9WLE9BQU87WUFLNEJBLHNCQUFBQTtRQUoxQyxvQkFBb0I7UUFDcEJJLFFBQVFKLEtBQUssQ0FBQyx3QkFBd0JBO1FBRXRDLDhCQUE4QjtRQUM5QixNQUFNK0IsZUFBZS9CLE1BQU1TLFdBQVcsTUFBSVQsa0JBQUFBLE1BQU1HLFFBQVEsY0FBZEgsdUNBQUFBLHVCQUFBQSxnQkFBZ0JVLElBQUksY0FBcEJWLDJDQUFBQSxxQkFBc0JNLE9BQU8sS0FBSU4sTUFBTU0sT0FBTyxJQUFJO1FBQzVGLE1BQU0wQixXQUFXLElBQUlDLE1BQU1GO1FBQzNCQyxTQUFTN0IsUUFBUSxHQUFHSCxNQUFNRyxRQUFRO1FBQ2xDNkIsU0FBU3ZDLE9BQU8sR0FBR08sTUFBTVAsT0FBTztRQUNoQyxNQUFNdUM7SUFDUjtBQUNGLEVBQUU7QUFFSyxNQUFNRSxTQUFTLE9BQU9aLE1BQU1QLE9BQU9DO0lBQ3hDLElBQUk7UUFDRixtQ0FBbUM7UUFDbkMsTUFBTUMsY0FBYzFCLGlDQUNETSxhQUFhQyxPQUFPLENBQUMsdUJBQXVCO1FBRS9ELElBQUltQixhQUFhO1lBQ2ZiLFFBQVFDLEdBQUcsQ0FBQztZQUVaLHlCQUF5QjtZQUN6QixNQUFNLElBQUlKLFFBQVFpQixDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1lBRWpELHVCQUF1QjtZQUN2QnJCLGFBQWFnQixPQUFPLENBQUMsY0FBYztZQUVuQyx3QkFBd0I7WUFDeEJoQixhQUFhZ0IsT0FBTyxDQUFDLG9CQUFvQk8sS0FBS0MsU0FBUyxDQUFDO2dCQUN0REMsTUFBTUE7Z0JBQ05QLE9BQU9BO2dCQUNQUyxpQkFBaUI7b0JBQ2ZDLFdBQVcsRUFBRTtvQkFDYkMsZ0JBQWdCLEVBQUU7b0JBQ2xCQyxxQkFBcUIsRUFBRTtnQkFDekI7WUFDRjtZQUVBLE9BQU87Z0JBQ0wvQixPQUFPO2dCQUNQZ0MsTUFBTTtvQkFDSkMsSUFBSTtvQkFDSlAsTUFBTUE7b0JBQ05QLE9BQU9BO2dCQUNUO1lBQ0Y7UUFDRjtRQUVBLGdCQUFnQjtRQUNoQixNQUFNWixXQUFXLE1BQU1wQixJQUFJK0MsSUFBSSxDQUFDLGdCQUFnQjtZQUFFUjtZQUFNUDtZQUFPQztRQUFTO1FBRXhFLGtCQUFrQjtRQUNsQixJQUFJYixTQUFTTyxJQUFJLElBQUlQLFNBQVNPLElBQUksQ0FBQ2QsS0FBSyxFQUFFO1lBQ3hDQyxhQUFhZ0IsT0FBTyxDQUFDLGNBQWNWLFNBQVNPLElBQUksQ0FBQ2QsS0FBSztRQUN4RDtRQUVBLE9BQU9PLFNBQVNPLElBQUk7SUFDdEIsRUFBRSxPQUFPVixPQUFPO1lBS1ZBLGlCQVNzQ0Esc0JBQUFBO1FBYjFDLG9CQUFvQjtRQUNwQkksUUFBUUosS0FBSyxDQUFDLHlCQUF5QkE7UUFFdkMsdUNBQXVDO1FBQ3ZDLElBQUlBLEVBQUFBLGtCQUFBQSxNQUFNRyxRQUFRLGNBQWRILHNDQUFBQSxnQkFBZ0JPLE1BQU0sTUFBSyxPQUMzQlAsTUFBTUcsUUFBUSxDQUFDTyxJQUFJLENBQUNKLE9BQU8sQ0FBQzZCLFFBQVEsQ0FBQyxtQkFBbUI7WUFDMUQsTUFBTUgsV0FBVyxJQUFJQyxNQUFNO1lBQzNCRCxTQUFTN0IsUUFBUSxHQUFHSCxNQUFNRyxRQUFRO1lBQ2xDNkIsU0FBU3ZDLE9BQU8sR0FBR08sTUFBTVAsT0FBTztZQUNoQyxNQUFNdUM7UUFDUjtRQUVBLDhCQUE4QjtRQUM5QixNQUFNRCxlQUFlL0IsTUFBTVMsV0FBVyxNQUFJVCxtQkFBQUEsTUFBTUcsUUFBUSxjQUFkSCx3Q0FBQUEsdUJBQUFBLGlCQUFnQlUsSUFBSSxjQUFwQlYsMkNBQUFBLHFCQUFzQk0sT0FBTyxLQUFJTixNQUFNTSxPQUFPLElBQUk7UUFDNUYsTUFBTTBCLFdBQVcsSUFBSUMsTUFBTUY7UUFDM0JDLFNBQVM3QixRQUFRLEdBQUdILE1BQU1HLFFBQVE7UUFDbEM2QixTQUFTdkMsT0FBTyxHQUFHTyxNQUFNUCxPQUFPO1FBQ2hDLE1BQU11QztJQUNSO0FBQ0YsRUFBRTtBQUVLLE1BQU1JLFNBQVM7SUFDcEIsSUFBSSxJQUE2QixFQUFFO1FBQ2pDdkMsYUFBYVcsVUFBVSxDQUFDO1FBQ3hCWCxhQUFhVyxVQUFVLENBQUM7SUFDMUI7QUFDRixFQUFFO0FBRUssTUFBTTZCLGlCQUFpQjtJQUM1QixJQUFJO1FBQ0YsbUNBQW1DO1FBQ25DLE1BQU1wQixjQUFjMUIsaUNBQ0RNLGFBQWFDLE9BQU8sQ0FBQyx1QkFBdUI7UUFFL0QsSUFBSW1CLGFBQWE7WUFDZmIsUUFBUUMsR0FBRyxDQUFDO1lBRVosZ0RBQWdEO1lBQ2hELE1BQU1pQyxXQUFXLEtBQTZCLEdBQzVDbEIsS0FBS21CLEtBQUssQ0FBQzFDLGFBQWFDLE9BQU8sQ0FBQyx1QkFBdUIsUUFBUSxDQUFFO1lBRW5FLE9BQU87Z0JBQ0wrQixJQUFJO2dCQUNKUCxNQUFNZ0IsU0FBU2hCLElBQUksSUFBSTtnQkFDdkJQLE9BQU91QixTQUFTdkIsS0FBSyxJQUFJO2dCQUN6QnlCLGFBQWFGLFNBQVNkLGVBQWUsSUFBSTtvQkFDdkNDLFdBQVcsRUFBRTtvQkFDYkMsZ0JBQWdCLEVBQUU7b0JBQ2xCQyxxQkFBcUIsRUFBRTtnQkFDekI7WUFDRjtRQUNGO1FBRUEsTUFBTXhCLFdBQVcsTUFBTXBCLElBQUkwRCxHQUFHLENBQUM7UUFDL0IsT0FBT3RDLFNBQVNPLElBQUk7SUFDdEIsRUFBRSxPQUFPVixPQUFPO1FBQ2RJLFFBQVFKLEtBQUssQ0FBQywyQkFBMkJBO1FBQ3pDLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFFRixxQ0FBcUM7QUFDOUIsTUFBTTBDLGtCQUFrQjtJQUM3QixJQUFJLEtBQTZCLEVBQUUsRUFBYTtJQUNoRCxPQUFPLENBQUMsQ0FBQzdDLGFBQWFDLE9BQU8sQ0FBQztBQUNoQyxFQUFFIiwic291cmNlcyI6WyJEOlxcU3R1ZGllc1xcQ29kaW5nXFxPblJvdXRlXFxhaS1yb2FkdHJpcC1mcm9udGVuZFxcbGliXFxhdXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcblxyXG4vLyBDcmVhdGUgQVBJIGNsaWVudCB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZ1xyXG5jb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xyXG4gIGJhc2VVUkw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGknLFxyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfSxcclxuICB0aW1lb3V0OiA1MDAwLCAvLyBSZWR1Y2VkIHRpbWVvdXQgdG8gNSBzZWNvbmRzXHJcbn0pO1xyXG5cclxuLy8gRGV0ZWN0IGlmIHdlJ3JlIGluIGRldmVsb3BtZW50IG1vZGUgYW5kIHRoZXJlJ3Mgbm8gYmFja2VuZFxyXG5jb25zdCBpc0RldmVsb3BtZW50V2l0aG91dEJhY2tlbmQgPSAoKSA9PiB7XHJcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMO1xyXG59O1xyXG5cclxuLy8gQWRkIGEgcmVxdWVzdCBpbnRlcmNlcHRvciB0byBpbmNsdWRlIHRoZSBhdXRoIHRva2VuIGluIHJlcXVlc3RzXHJcbmFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXHJcbiAgKGNvbmZpZykgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vIENoZWNrIGlmIHJ1bm5pbmcgb24gY2xpZW50IHNpZGVcclxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aF90b2tlbicpO1xyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb25maWc7XHJcbiAgfSxcclxuICAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKVxyXG4pO1xyXG5cclxuLy8gSGFuZGxlIGF1dGhlbnRpY2F0aW9uIGVycm9ycyBjb25zaXN0ZW50bHlcclxuYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXHJcbiAgKHJlc3BvbnNlKSA9PiByZXNwb25zZSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCdBUEkgZXJyb3IgaW50ZXJjZXB0ZWQ6JywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICBcclxuICAgIC8vIEFkZCBtb3JlIGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uIGZvciBhdXRoIGVycm9yc1xyXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XHJcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgIC8vIENsZWFyIHRva2VucyBvbiBhdXRoIGZhaWx1cmVcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoX3Rva2VuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBhIHVzZXItZnJpZW5kbHkgbWVzc2FnZVxyXG4gICAgICAgIGVycm9yLnVzZXJNZXNzYWdlID0gJ1lvdXIgc2Vzc2lvbiBoYXMgZXhwaXJlZC4gUGxlYXNlIGxvZ2luIGFnYWluLic7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwMCAmJiBlcnJvci5yZXNwb25zZS5kYXRhPy5tZXNzYWdlKSB7XHJcbiAgICAgICAgLy8gUGFzcyBhbG9uZyB0aGUgc2VydmVyIG1lc3NhZ2VcclxuICAgICAgICBlcnJvci51c2VyTWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlLmRhdGEubWVzc2FnZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChlcnJvci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJykge1xyXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB0aW1lb3V0c1xyXG4gICAgICBlcnJvci51c2VyTWVzc2FnZSA9ICdSZXF1ZXN0IHRpbWVkIG91dC4gUGxlYXNlIGNoZWNrIHlvdXIgY29ubmVjdGlvbiBhbmQgdHJ5IGFnYWluLic7XHJcbiAgICAgIGNvbnNvbGUud2FybignQVBJIHJlcXVlc3QgdGltZWQgb3V0IC0gc3dpdGNoaW5nIHRvIGRldmVsb3BtZW50IG1vZGUnKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEZvcmNlIGRldmVsb3BtZW50IG1vZGUgb24gdGltZW91dFxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZGV2X21vZGVfZm9yY2VkJywgJ3RydWUnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICB9XHJcbik7XHJcblxyXG5leHBvcnQgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWwsIHBhc3N3b3JkKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCB1c2UgbW9jayBkYXRhXHJcbiAgICBjb25zdCB1c2VNb2NrRGF0YSA9IGlzRGV2ZWxvcG1lbnRXaXRob3V0QmFja2VuZCgpIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkZXZfbW9kZV9mb3JjZWQnKSA9PT0gJ3RydWUnO1xyXG4gICAgXHJcbiAgICBpZiAodXNlTW9ja0RhdGEpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIG1vY2sgbG9naW4gaW4gZGV2ZWxvcG1lbnQgbW9kZScpO1xyXG4gICAgICBcclxuICAgICAgLy8gU2ltdWxhdGUgbmV0d29yayBkZWxheVxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSB0aGUgbW9jayB0b2tlblxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0aF90b2tlbicsICdtb2NrLWp3dC10b2tlbicpO1xyXG4gICAgICBcclxuICAgICAgLy8gU3RvcmUgYmFzaWMgdXNlciBkYXRhXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyX3ByZWZlcmVuY2VzJywgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIG5hbWU6IGVtYWlsLnNwbGl0KCdAJylbMF0sXHJcbiAgICAgICAgZW1haWw6IGVtYWlsLFxyXG4gICAgICAgIGZvb2RQcmVmZXJlbmNlczoge1xyXG4gICAgICAgICAgZm9vZFR5cGVzOiBbJ0Zhc3QgRm9vZCcsICdNZXhpY2FuJ10sXHJcbiAgICAgICAgICBmYXZvcml0ZUNoYWluczogWydUYWNvIEJlbGwnLCAnTWNEb25hbGRcXCdzJ10sXHJcbiAgICAgICAgICBkaWV0YXJ5UmVzdHJpY3Rpb25zOiBbXVxyXG4gICAgICAgIH1cclxuICAgICAgfSkpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b2tlbjogJ21vY2stand0LXRva2VuJyxcclxuICAgICAgICB1c2VyOiB7XHJcbiAgICAgICAgICBpZDogJzEyMycsXHJcbiAgICAgICAgICBuYW1lOiBlbWFpbC5zcGxpdCgnQCcpWzBdLFxyXG4gICAgICAgICAgZW1haWw6IGVtYWlsLFxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUmVhbCBBUEkgY2FsbFxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvbG9naW4nLCB7IGVtYWlsLCBwYXNzd29yZCB9KTtcclxuICAgIFxyXG4gICAgLy8gU3RvcmUgdGhlIHRva2VuXHJcbiAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLnRva2VuKSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoX3Rva2VuJywgcmVzcG9uc2UuZGF0YS50b2tlbik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAvLyBMb2cgZm9yIGRlYnVnZ2luZ1xyXG4gICAgY29uc29sZS5lcnJvcignTG9naW4gZXJyb3IgZGV0YWlsczonLCBlcnJvcik7XHJcbiAgICBcclxuICAgIC8vIFRocm93IGEgbW9yZSBkZXRhaWxlZCBlcnJvclxyXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IudXNlck1lc3NhZ2UgfHwgZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZSB8fCAnTG9naW4gZmFpbGVkJztcclxuICAgIGNvbnN0IGVycm9yT2JqID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICBlcnJvck9iai5yZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlO1xyXG4gICAgZXJyb3JPYmoucmVxdWVzdCA9IGVycm9yLnJlcXVlc3Q7XHJcbiAgICB0aHJvdyBlcnJvck9iajtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2lnbnVwID0gYXN5bmMgKG5hbWUsIGVtYWlsLCBwYXNzd29yZCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgdXNlIG1vY2sgZGF0YVxyXG4gICAgY29uc3QgdXNlTW9ja0RhdGEgPSBpc0RldmVsb3BtZW50V2l0aG91dEJhY2tlbmQoKSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGV2X21vZGVfZm9yY2VkJykgPT09ICd0cnVlJztcclxuICAgIFxyXG4gICAgaWYgKHVzZU1vY2tEYXRhKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBtb2NrIHNpZ251cCBpbiBkZXZlbG9wbWVudCBtb2RlJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTaW11bGF0ZSBuZXR3b3JrIGRlbGF5XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIHRoZSBtb2NrIHRva2VuXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoX3Rva2VuJywgJ21vY2stand0LXRva2VuJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSBiYXNpYyB1c2VyIGRhdGFcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXJfcHJlZmVyZW5jZXMnLCBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICBlbWFpbDogZW1haWwsXHJcbiAgICAgICAgZm9vZFByZWZlcmVuY2VzOiB7XHJcbiAgICAgICAgICBmb29kVHlwZXM6IFtdLFxyXG4gICAgICAgICAgZmF2b3JpdGVDaGFpbnM6IFtdLFxyXG4gICAgICAgICAgZGlldGFyeVJlc3RyaWN0aW9uczogW11cclxuICAgICAgICB9XHJcbiAgICAgIH0pKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9rZW46ICdtb2NrLWp3dC10b2tlbicsXHJcbiAgICAgICAgdXNlcjoge1xyXG4gICAgICAgICAgaWQ6ICcxMjMnLFxyXG4gICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgIGVtYWlsOiBlbWFpbCxcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFJlYWwgQVBJIGNhbGxcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3NpZ251cCcsIHsgbmFtZSwgZW1haWwsIHBhc3N3b3JkIH0pO1xyXG4gICAgXHJcbiAgICAvLyBTdG9yZSB0aGUgdG9rZW5cclxuICAgIGlmIChyZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEudG9rZW4pIHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhfdG9rZW4nLCByZXNwb25zZS5kYXRhLnRva2VuKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIC8vIExvZyBmb3IgZGVidWdnaW5nXHJcbiAgICBjb25zb2xlLmVycm9yKCdTaWdudXAgZXJyb3IgZGV0YWlsczonLCBlcnJvcik7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGZvciBlbWFpbCBhbHJlYWR5IGV4aXN0cyBlcnJvclxyXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMCAmJiBcclxuICAgICAgICBlcnJvci5yZXNwb25zZS5kYXRhLm1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykpIHtcclxuICAgICAgY29uc3QgZXJyb3JPYmogPSBuZXcgRXJyb3IoJ1RoaXMgZW1haWwgaXMgYWxyZWFkeSByZWdpc3RlcmVkJyk7XHJcbiAgICAgIGVycm9yT2JqLnJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2U7XHJcbiAgICAgIGVycm9yT2JqLnJlcXVlc3QgPSBlcnJvci5yZXF1ZXN0O1xyXG4gICAgICB0aHJvdyBlcnJvck9iajtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVGhyb3cgYSBtb3JlIGRldGFpbGVkIGVycm9yXHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci51c2VyTWVzc2FnZSB8fCBlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlIHx8ICdTaWdudXAgZmFpbGVkJztcclxuICAgIGNvbnN0IGVycm9yT2JqID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICBlcnJvck9iai5yZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlO1xyXG4gICAgZXJyb3JPYmoucmVxdWVzdCA9IGVycm9yLnJlcXVlc3Q7XHJcbiAgICB0aHJvdyBlcnJvck9iajtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9nb3V0ID0gKCkgPT4ge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhfdG9rZW4nKTtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdkZXZfbW9kZV9mb3JjZWQnKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFVzZXIgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCB1c2UgbW9jayBkYXRhXHJcbiAgICBjb25zdCB1c2VNb2NrRGF0YSA9IGlzRGV2ZWxvcG1lbnRXaXRob3V0QmFja2VuZCgpIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkZXZfbW9kZV9mb3JjZWQnKSA9PT0gJ3RydWUnO1xyXG4gICAgXHJcbiAgICBpZiAodXNlTW9ja0RhdGEpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIG1vY2sgdXNlciBkYXRhIGluIGRldmVsb3BtZW50IG1vZGUnKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCBzdG9yZWQgdXNlciBwcmVmZXJlbmNlcyBvciBjcmVhdGUgZGVmYXVsdFxyXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gXHJcbiAgICAgICAgSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcl9wcmVmZXJlbmNlcycpIHx8ICd7fScpIDoge307XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiAnMTIzJyxcclxuICAgICAgICBuYW1lOiB1c2VyRGF0YS5uYW1lIHx8ICdUZXN0IFVzZXInLFxyXG4gICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCB8fCAndGVzdEBleGFtcGxlLmNvbScsXHJcbiAgICAgICAgcHJlZmVyZW5jZXM6IHVzZXJEYXRhLmZvb2RQcmVmZXJlbmNlcyB8fCB7XHJcbiAgICAgICAgICBmb29kVHlwZXM6IFtdLFxyXG4gICAgICAgICAgZmF2b3JpdGVDaGFpbnM6IFtdLFxyXG4gICAgICAgICAgZGlldGFyeVJlc3RyaWN0aW9uczogW11cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2F1dGgvbWUnKTtcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdHZXQgY3VycmVudCB1c2VyIGVycm9yOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENoZWNrIGlmIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWRcclxuZXhwb3J0IGNvbnN0IGlzQXV0aGVudGljYXRlZCA9ICgpID0+IHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcclxuICByZXR1cm4gISFsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aF90b2tlbicpO1xyXG59OyAiXSwibmFtZXMiOlsiYXhpb3MiLCJhcGkiLCJjcmVhdGUiLCJiYXNlVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJoZWFkZXJzIiwidGltZW91dCIsImlzRGV2ZWxvcG1lbnRXaXRob3V0QmFja2VuZCIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJBdXRob3JpemF0aW9uIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsInN0YXR1cyIsInJlbW92ZUl0ZW0iLCJ1c2VyTWVzc2FnZSIsImRhdGEiLCJjb2RlIiwid2FybiIsInNldEl0ZW0iLCJsb2dpbiIsImVtYWlsIiwicGFzc3dvcmQiLCJ1c2VNb2NrRGF0YSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiSlNPTiIsInN0cmluZ2lmeSIsIm5hbWUiLCJzcGxpdCIsImZvb2RQcmVmZXJlbmNlcyIsImZvb2RUeXBlcyIsImZhdm9yaXRlQ2hhaW5zIiwiZGlldGFyeVJlc3RyaWN0aW9ucyIsInVzZXIiLCJpZCIsInBvc3QiLCJlcnJvck1lc3NhZ2UiLCJlcnJvck9iaiIsIkVycm9yIiwic2lnbnVwIiwiaW5jbHVkZXMiLCJsb2dvdXQiLCJnZXRDdXJyZW50VXNlciIsInVzZXJEYXRhIiwicGFyc2UiLCJwcmVmZXJlbmNlcyIsImdldCIsImlzQXV0aGVudGljYXRlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.js\n"));

/***/ })

});